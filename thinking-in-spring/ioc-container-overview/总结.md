ApplicationContext是BeanFactory的子接口，说明ApplicationContext is BeanFactory。并且ApplicationContext 是BeanFactory的包装类，
也就是内部组合了BeanFactory的实现-DefaultListableBeanFactory。为什么包装了DefaultListableBeanFactory，
因为它需要简化且丰富功能来为企业开发提供更高的便捷性，也就是说ApplicationContext 是DefaultListableBeanFactory的超集。
至于为什么UserRepository注入的BeanFactory 不等于ClassPathXmlApplicationContext得到的BeanFactory ，
是因为AbstractApplicationContext#prepareBeanFactory中 
指明了 beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); 
也就是说当byType是BeanFactory.class的时候，获得是的ApplicationContext中的DefaultListableBeanFactory对象。
那真正的IOC的底层实现就是BeanFactory的实现类，因为ApplicationContext是委托DefaultListableBeanFactory来操作getBean等方法的。



在UserRepository中注入的beanFactory是DefaultListableBeanFactory，
若我将代码private BeanFactory beanFactory;改为private ClassPathXmlApplicationContext classPathXmlApplicationContext;
然后给出get、set后，userRepository.getClassPathXmlApplicationContext()==beanFactory则为true，
那么此时我是不是就拿到了比DefaultListableBeanFactory还要牛的classPathXmlApplicationContext，然后可以为所欲为了?
作者回复: 万所欲为不确定，但是可以干很多“坏“事。


小马哥，通过视频我了解了ApplicationContext和BeanFactory之间的关系，
也知道了DefaultListableBeanFactory被组合到了AbstractRefreshableApplicationContext，
但好像视频并没有回答一个问题：UserRepository中的BeanFactory beanFactory属性为什么通过autowired=“byType”，
注入的是DefaultListableBeanFactory，而不是ClassPathXmlApplicationContext？
既然他们两者属于BeanFactory接口，按type注入，为什么不是ClassPathXmlApplicationContext？是框架哪里设置的吗？

作者回复: 答案在 org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory 方法中，其中：
beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
beanFactory.registerResolvableDependency(ResourceLoader.class, this);
beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
beanFactory.registerResolvableDependency(ApplicationContext.class, this);
以上代码明确地指定了 BeanFactory 类型的对象是 ApplicationContext#getBeanFactory() 方法的内容，而非它自生。